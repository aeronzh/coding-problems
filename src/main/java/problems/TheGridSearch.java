package problems;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.Scanner;

/**
 * Given a 2D array of digits, try to find the occurrence of a given 2D pattern
 * of digits. For example, consider the following 2D matrix:
 * 
 * 1234567890
 * 
 * 0987654321
 * 
 * 1111111111
 * 
 * 1111111111
 * 
 * 2222222222
 * 
 * Assume we need to look for the following 2D pattern:
 * 
 * 876543
 * 
 * 111111
 * 
 * 111111
 * 
 * If we scan through the original array, we observe that the 2D pattern begins
 * at the second row and the third column of the larger grid (the 88 in the
 * second row and third column of the larger grid is the top-left corner of the
 * pattern we are searching for).
 * 
 * So, a 2D pattern of P digits is said to be present in a larger grid G, if the
 * latter contains a contiguous, rectangular 2D grid of digits matching with the
 * pattern PP, similar to the example shown above.
 * 
 * Input Format The first line contains an integer, T, which is the number of
 * test cases. T test cases follow, each having a structure as described below:
 * The first line contains two space-separated integers, R and C, indicating the
 * number of rows and columns in the grid G, respectively. This is followed by R
 * lines, each with a string of CC digits, which represent the grid G. The
 * following line contains two space-separated integers, r and c, indicating the
 * number of rows and columns in the pattern grid PP. This is followed by r
 * lines, each with a string of c digits, which represent the pattern P.
 * 
 * Constraints 1≤T≤5 1≤R,r,C,c≤1000 1≤r≤R 1≤c≤C Test Case Generation Each
 * individual test case has been generated by first specifying the size (R and
 * C) of the large 2D matrix, and then randomly generating the digits in it. A
 * limited number of digits in the larger matrix may be changed by the problem
 * setter (no more than 5% of the total number of digits in the matrix). So the
 * larger 2D matrix is almost-random. The pattern matrix has been
 * manually-curated by the problem setter.
 * 
 * Output Format Display 'YES' or 'NO', depending on whether (or not) you find
 * that the larger grid G contains the rectangular pattern P. The evaluation
 * will be case sensitive.
 * 
 * @author lucas
 *
 */
public class TheGridSearch {
	private static String solve(int[][] grid, int[][] pattern) {
		int gRows = grid.length;
		int gColumns = grid[0].length;
		int pRows = pattern.length;
		int pColumns = pattern[0].length;

		for (int gr = 0; gr <= gRows - pRows; gr++) {
			for (int gc = 0; gc <= gColumns - pColumns; gc++) {
				if (grid[gr][gc] == pattern[0][0]) {
					boolean found = true;
					PATTERN_CHECK: for (int r = 0; r < pRows; r++) {
						for (int c = 0; c < pColumns; c++) {
							if (grid[gr + r][gc + c] != pattern[r][c]) {
								found = false;
								break PATTERN_CHECK;
							}
						}
					}

					if (found) {
						return "YES";
					}
				}
			}
		}

		return "NO";
	}

	public static void main(String[] args) throws FileNotFoundException {
		System.setIn(new FileInputStream(System.getProperty("user.home") + "/" + "in.txt"));
		Scanner outputScanner = new Scanner(new FileInputStream(System.getProperty("user.home") + "/" + "out.txt"));

		Scanner scanner = new Scanner(System.in);

		int tests = scanner.nextInt();
		for (int t = 0; t < tests; t++) {
			// Grid
			int rows = scanner.nextInt();
			int columns = scanner.nextInt();
			int[][] grid = new int[rows][columns];

			for (int r = 0; r < rows; r++) {
				String line = scanner.next();
				for (int c = 0; c < line.length(); c++) {
					grid[r][c] = Integer.parseInt("" + line.charAt(c));
				}
			}

			// Pattern
			int patternRows = scanner.nextInt();
			int patternColumns = scanner.nextInt();
			int[][] pattern = new int[patternRows][patternColumns];

			for (int r = 0; r < patternRows; r++) {
				String line = scanner.next();
				for (int c = 0; c < line.length(); c++) {
					pattern[r][c] = Integer.parseInt("" + line.charAt(c));
				}
			}

			System.out.println(solve(grid, pattern));
		}
	}
}
